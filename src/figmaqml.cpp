#include "figmadocument.h"
#include "figmaparser.h"
#include "figmaqml.h"
#include "fontcache.h"
#include "utils.h"
#include <QVersionNumber>
#include <QTimer>
#include <QFile>
#include <QSize>
#include <QQmlEngine>
#include <QDir>
#include <QFontDatabase>
#include <QFontInfo>
#include <QStandardPaths>
#include <exception>



#ifndef NO_CONCURRENT
#include <QtConcurrent>
template <class T> using Future = QFuture<T>;
namespace Concurrent = QtConcurrent;
template <class T> using FutureWatcher = QFutureWatcher<T>;
#endif

#include <QTime>
#define TIMED_START(s)  const auto s = QTime::currentTime();
#define TIMED_END(s, p) if(m_flags & Timed ) {emit info(toStr("timed", p, s.msecsTo(QTime::currentTime())));}

class RAII_ {
public:
    using Deldelegate = std::function<void()>;
    RAII_(const Deldelegate& d) : m_d(d) {}
    ~RAII_() {m_d();}
private:
    Deldelegate m_d;
};

#define SCAT(a, b) a ## b
#define SCAT2(a, b) SCAT(a, b)
#define RAII(x) RAII_ SCAT2(raii, __LINE__)(x)

using namespace std::chrono_literals;

const QLatin1String qmlViewPath("/qml/");
const QLatin1String sourceViewPath("/sources/");
const QLatin1String Images("/images/");
const QLatin1String FileHeader("//Generated by FigmaQML\n\n");

static int levenshteinDistance(const QString& s1, const QString& s2) {
    const auto l1 = s1.length();
    const auto l2 = s2.length();

    auto dist = std::vector<std::vector<int>>(l2 + 1, std::vector<int>(l1 + 1));


    for(auto i = 0; i <= l1 ; i++) {
       dist[0][i] = i;
    }

    for(auto j = 0; j <= l2; j++) {
       dist[j][0] = j;
    }
    for (auto j = 1; j <= l1; j++) {
       for(auto i = 1; i <= l2 ;i++) {
          const auto track = (s2[i-1] == s1[j-1]) ? 0 : 1;
          const auto t = std::min((dist[i - 1][j] + 1), (dist[i][j - 1] + 1));
          dist[i][j] = std::min(t, (dist[i - 1][j - 1] + track));
       }
    }
    return dist[l2][l1];
}

enum Format {
    None = 0, JPEG, PNG
};

FigmaQml::~FigmaQml() {
}

int FigmaQml::canvasCount() const {
    return m_uiDoc ? m_uiDoc->size() : 0;
}

int FigmaQml::elementCount() const {
    return m_uiDoc && canvasCount() > 0 ? m_uiDoc->current().size() : 0;
}

int FigmaQml::currentElement() const {
    return (m_uiDoc && !m_uiDoc->empty()) ? m_uiDoc->current().currentIndex() : 0;
}

int FigmaQml::currentCanvas() const {
    return m_uiDoc ? m_uiDoc->currentIndex() : 0;
}

QString FigmaQml::canvasName() const {
    return m_uiDoc ? m_uiDoc->current().name() : "";
}

QString FigmaQml::documentName() const {
    return m_uiDoc ? m_uiDoc->name() : "";
}

QString FigmaQml::qmlDir() const {
    return m_qmlDir;
}

QString FigmaQml::elementName() const {
    return (m_uiDoc && !m_uiDoc->empty()) ? m_uiDoc->current().name(currentElement()) : QString();
}

QString FigmaQml::documentsLocation() const {
    return QStandardPaths::writableLocation(QStandardPaths::DocumentsLocation);
}

const auto FrameDelay = 500ms;

bool FigmaQml::setCurrentElement(int current) {
    if(current < 0 || current >= elementCount())
        return false;
    if(current != currentElement()) {
        m_uiDoc->getCurrent()->setCurrent(current);
        emit elementNameChanged();
        QTimer::singleShot(FrameDelay, this, [this](){emit currentElementChanged();}); //delayed
    }
    return true;
}

bool FigmaQml::setCurrentCanvas(int current) {
    if(current < 0 || current >= canvasCount())
        return false;
    if(current != currentCanvas()) {
        m_uiDoc->setCurrent(current);
        if(m_uiDoc->currentIndex() >= m_uiDoc->current().size()) {
            m_uiDoc->getCurrent()->setCurrent(m_uiDoc->current().size() - 1);
        }
        emit currentCanvasChanged();
        emit elementNameChanged();
        emit elementCountChanged();
        QTimer::singleShot(FrameDelay, this, [this](){emit currentElementChanged();}); //delayed
    }
    return true;
}



QString FigmaQml::validFileName(const QString& name) {
   return FigmaParser::validFileName(name);
}

bool FigmaQml::saveAllQML(const QString& folderName) {
#ifdef Q_OS_WINDOWS
    QDir d(folderName.startsWith('/') ? folderName.mid(1) : folderName);
#else
    QDir d(folderName);
#endif
    if(!ensureDirExists(d.absolutePath())) {
        return false;
    }
    QSet<QString> componentNames;
    for(const auto& c : *m_sourceDoc) {
        for(const auto& e : *c) {
            const auto fullname = QString("%1/%2_%3.qml").arg(d.absolutePath()).arg(validFileName(c->name())).arg(e->name());
            QFile file(fullname);
            if(!file.open(QIODevice::WriteOnly)) {
                emit error(QString("Failed to write %1 %2 %3 %4").arg(file.errorString(), fullname, d.absolutePath(), e->name()));
                return false;
            }
            if(e->data().length() == 0 || file.write(e->data()) < 0) {
                emit error(QString("Failed to write %1 %2 %3 %4").arg(file.errorString(), fullname, d.absolutePath(), e->name()));
                return false;
            }
            const auto elementComponents = m_sourceDoc->components(e->name());
            componentNames.unite(QSet(elementComponents.begin(), elementComponents.end()));
        }
    }

    for(const auto& componentName : componentNames) {
        Q_ASSERT(componentName.endsWith(FIGMA_SUFFIX));
        const auto fullname = QString("%1/%2.qml").arg(d.absolutePath()).arg(componentName);
        QFile file(fullname);
        if(!file.open(QIODevice::WriteOnly)) {
            emit error(QString("Failed to write \"%1\" \"%2\" \"%3\" \"%4\"").arg(file.errorString(), fullname, d.absolutePath(), componentName));
            return false;
        }

        if(!m_sourceDoc->containsComponent(componentName)) {
            emit error(QString("Failed to find \"%1\" on write").arg(componentName));
            return false;
        }

        const auto cd = m_sourceDoc->component(componentName);
        if(cd.length() == 0 || file.write(cd) < 0) {
            emit error(QString("Failed to write \"%1\" \"%2\" \"%3\" \"%4\"").arg(file.errorString(), fullname, d.absolutePath(), componentName));
            return false;
        }
    }

    if(!saveImages(d.absolutePath() + Images))
        return false;
    emit info(QString("%1 files written into %2").arg(m_imageFiles.size() + componentNames.count()
                                                      + std::accumulate(m_sourceDoc->begin(), m_sourceDoc->end(), 0, [](const auto &a, const auto& c){return a + c->size();}))
              .arg(d.absolutePath()));
    return true;
}

QUrl FigmaQml::element() const {
      return (m_uiDoc && !m_uiDoc->empty()) ?  QUrl::fromLocalFile(QString(m_uiDoc->current().current())) : QUrl();
}

QByteArray FigmaQml::sourceCode() const {
      return (m_sourceDoc && !m_sourceDoc->empty()) ?  m_sourceDoc->current().current() : QByteArray();
}

FigmaQml::FigmaQml(const QString& qmlDir, const QString& fontFolder, FigmaProvider& provider, QObject *parent) : QObject(parent),
    m_qmlDir(qmlDir), mProvider(provider), m_imports(defaultImports()), m_fontCache(std::make_unique<FontCache>()), m_fontFolder(fontFolder) {
    qmlRegisterUncreatableType<FigmaQml>("FigmaQml", 1, 0, "FigmaQml", "");
    QObject::connect(this, &FigmaQml::currentElementChanged, this, [this]() {
        m_sourceDoc->getCurrent()->setCurrent(m_uiDoc->getCurrent()->currentIndex());
    });
    QObject::connect(this, &FigmaQml::currentCanvasChanged, this, [this]() {
        m_sourceDoc->setCurrent(m_uiDoc->currentIndex());
    });
    QObject::connect(this, &FigmaQml::sourceCodeChanged, this, &FigmaQml::elementChanged);
    QObject::connect(this, &FigmaQml::currentElementChanged, this, &FigmaQml::sourceCodeChanged);
    QObject::connect(this, &FigmaQml::currentCanvasChanged, this, &FigmaQml::sourceCodeChanged);
    QObject::connect(this, &FigmaQml::currentElementChanged, this, &FigmaQml::elementNameChanged);
    QObject::connect(this, &FigmaQml::currentElementChanged, this, &FigmaQml::componentsChanged);
    QObject::connect(this, &FigmaQml::currentCanvasChanged, this, &FigmaQml::canvasNameChanged);
    QObject::connect(this, &FigmaQml::imageDimensionMaxChanged, this, [this]() {
        if(m_imageDimensionMax <= 0) {
            m_imageDimensionMax = 1024;
        }
    });

    const auto fontFolderChanged = [this]() {
        const QDir fontFolder(m_fontFolder);
        if(!fontFolder.exists())
            emit warning(QString("Folder \"%1\", not found").arg(m_fontFolder));
        for(const auto& entry : fontFolder.entryInfoList()) {
            emit info(entry.fileName());
            if(!entry.fileName().endsWith(".txt")&& QFontDatabase::addApplicationFont(entry.absoluteFilePath()) < 0)
                emit warning(QString("Font \"%1\", cannot be loaded").arg(entry.absoluteFilePath()));
        }
    };

    QObject::connect(this, QOverload<FigmaFileDocument*>::of(&FigmaQml::figmaDocumentCreated), this, [this](FigmaFileDocument* doc) {
        Q_ASSERT(doc->type() == FigmaFileDocument::type());
        Q_ASSERT(!m_uiDoc);
        if(doc) {
            m_uiDoc.reset(doc);
            emit isValidChanged();
            emit canvasCountChanged();
            emit elementCountChanged();
            emit documentNameChanged();
            emit elementChanged();
            emit fontsChanged();
        } else {
            emit error("Invalid document");
        }
        if(mRestore)
            mRestore(doc);
        mRestore = nullptr;
    });

    QObject::connect(this, &FigmaQml::error, this, [this](const QString&) {
        if(mRestore)
            mRestore(false);
        mRestore = nullptr;
    });

    QObject::connect(this, QOverload<FigmaDataDocument*>::of(&FigmaQml::figmaDocumentCreated), this, [this](FigmaDataDocument* doc) {
        Q_ASSERT(doc->type() == FigmaDataDocument::type());
        Q_ASSERT(!m_sourceDoc);
        if(doc) {
            m_sourceDoc.reset(doc);
            emit sourceCodeChanged();
            emit documentCreated();
        } else {
            emit error("Invalid document");
        }
    });

    QObject::connect(this, &FigmaQml::fontFolderChanged, this, fontFolderChanged);
    fontFolderChanged();
}


QVariantMap FigmaQml::defaultImports() {
    return {
#ifdef QT5
        {"QtQuick", QString("2.15")},
        {"QtGraphicalEffects", QString("1.15")},
        {"QtQuick.Shapes", QString("1.15")}
#else
        {"QtQuick", QString("")},
        {"Qt5Compat.GraphicalEffects", QString("")},
        {"QtQuick.Shapes", QString("")}
#endif
    };
}

bool FigmaQml::setBrokenPlaceholder(const QString &placeholder) {
    QFile file(placeholder);
    if(!file.open(QIODevice::ReadOnly)) {
        return false;
    }
    m_brokenPlaceholder = "data:image/jpeg;base64," + file.readAll().toBase64();
    return true;
}


bool FigmaQml::isValid() const {
    return m_uiDoc && !m_uiDoc->empty();
}

QStringList FigmaQml::components() const {
    if(m_sourceDoc && !m_sourceDoc->empty()) {
        const auto currentElement =  m_sourceDoc->current().currentIndex();
        const auto key = m_sourceDoc->current().name(currentElement);
        return m_sourceDoc->components(key);
    } else {
        return QStringList();
    }
}

QByteArray FigmaQml::componentSourceCode(const QString &name) const {
    return (!name.isEmpty()) && m_sourceDoc && m_sourceDoc->containsComponent(name) ? m_sourceDoc->component(name) : QByteArray();
}

QString FigmaQml::componentData(const QString &name) const {
    return (!name.isEmpty()) && m_sourceDoc && m_sourceDoc->containsComponent(name) ? m_sourceDoc->componentData(name) : QString();
}

void FigmaQml::cancel() {
    emit cancelled();
}

void FigmaQml::doCancel() {
    m_doCancel = true;
}

void FigmaQml::setFilter(const QMap<int, QSet<int>>& filter) {
    m_filter = filter;
}

QByteArray FigmaQml::prettyData(const QByteArray& data) const {
    QJsonParseError error;
    const auto json = QJsonDocument::fromJson(data, &error);
    if(error.error != QJsonParseError::NoError) {
       return QString("JSON parse error: %1 at %2\n\n")
                .arg(error.errorString())
                .arg(error.offset).toLatin1() + data;
    }
    const auto bytes = json.toJson();
    return bytes;
}

bool FigmaQml::saveImages(const QString &folder) {
    if(!ensureDirExists(folder))
        return false;
    for(const auto& i : m_imageFiles) {
        const QFileInfo file(i.first + i.second);
        if(!file.exists()) {
            emit error(QString("Invalid filename %1").arg(file.absoluteFilePath()));
            return false;
        }
        const auto target = folder + file.fileName();
        if(!QFile::copy(file.absoluteFilePath(), target)) {
            emit error(QString("Cannot copy %1 to %2").arg(file.absoluteFilePath()).arg(target));
            return false;
        }
    }
    return true;
}

void FigmaQml::addImageFile(const QString& imageRef, bool isRendering) {
    if(isRendering){
        mProvider.getRendering(imageRef);
        QObject::connect(&mProvider, &FigmaProvider::imageReady, this, [this](const QString& imageRef, const QByteArray& bytes, int format) {
            addImageFileData(imageRef, bytes, format, true);
    });
    } else {
        mProvider.getImage(imageRef, QSize(m_imageDimensionMax, m_imageDimensionMax));
        QObject::connect(&mProvider, &FigmaProvider::imageReady, this, [this](const QString& imageRef, const QByteArray& bytes, int format) {
            addImageFileData(imageRef, bytes, format, false);
    });
    }
}

bool FigmaQml::addImageFileData(const QString& imageRef, const QByteArray& bytes, int mime, bool isRendering) {
    if(bytes.isEmpty())
        return false;
    const auto path = m_targetDir + Images.mid(1);
    int count = 1;
    static const QRegularExpression re(R"([\\\/:*?"<>|\s;])");
    auto name = imageRef;
    name.replace(re, QLatin1String("_"));
    Q_ASSERT(mime == PNG || mime == JPEG);
    const QString extension = mime == JPEG ? "jpg" : "png";
    auto imageName = QString("%1.%2").arg(name, extension);
    while(QFile::exists(imageName)) {
        imageName = QString("%1_%2.%3").arg(name).arg(count).arg(extension);
        ++count;
        }
    ensureDirExists(path);
    const auto filename = path + imageName;
    QFile file(filename);
    if(!file.open(QIODevice::WriteOnly)) {
        emit warning("error when write:" + imageRef + " " +  filename + " " + file.errorString());
        return false;
    }
    file.write(bytes);
    m_imageFiles.insert(imageRef, {path, imageName});
    return true;
}

bool FigmaQml::ensureDirExists(const QString& e) {
     QDir dir(e);
     if(!dir.mkpath(".")) {
         emit error(QString("Cannot use dir %1").arg(dir.absolutePath()));
         return false;
     }
     qDebug() << "Foo" << e << "is ok";
     return true;
}

QVariantMap FigmaQml::fonts() const {
    QVariantMap map;
    const auto c = m_fontCache->content();
    for(const auto& v : c)
        map.insert(v.first, v.second);
    return map;
}

void FigmaQml::setFonts(const QVariantMap& map) {
  const auto keys = map.keys();
  for (const auto &k : keys) {
    m_fontCache->insert(k, map[k].toString());
  }
}

template<class FigmaDocType>
void FigmaQml::createDocument(const QJsonObject& json) {
    m_state = State::Suspend;
    auto ctimer = new QTimer(this);
    QObject::connect(ctimer, &QTimer::timeout, this, [ctimer, this, json](){
        if(m_state == State::Suspend) {
            if(mProvider.isReady()) {
                m_state = State::Constructing;
                auto doc = doCreateDocument<FigmaDocType>(json);
                if(doc) {
                    ctimer->stop();
                    ctimer->deleteLater();
                    Q_ASSERT(FigmaDocType::type() == doc->type());
                    emit figmaDocumentCreated(doc.release());
                } else if(m_state != State::Suspend) {
                    parseError(FigmaParser::lastError(), true);
                }
            }
        } else {
            ctimer->stop();
            ctimer->deleteLater();
            emit figmaDocumentCreated(static_cast<FigmaDocType*>(nullptr));
        }
    });
    ctimer->start(500);
}

void FigmaQml::createDocumentView(const QByteArray &data, bool restoreView) {

    if(mRestore)
        return;
    const auto json = object(data);
    if(!json)
        return;
    cleanDir(m_qmlDir);
    m_imageFiles.clear();
    m_uiDoc.reset();
    if(!restoreView)
        m_fontCache->clear();
    emit isValidChanged();
    emit canvasCountChanged();
    emit elementCountChanged();
    emit documentNameChanged();
    m_targetDir = m_qmlDir + qmlViewPath;
    m_embedImages = true;

    const auto restoredCanvas = currentCanvas();
    const auto restoredElement = currentElement();

    mRestore = [this, restoreView, restoredElement, restoredCanvas, data](bool has_doc){
        if(has_doc)
             createDocumentSources(data);
        if(restoreView) {
            if(setCurrentCanvas(restoredCanvas))
                setCurrentElement(restoredElement);
        }
    };

    createDocument<FigmaFileDocument>(*json);
}


void FigmaQml::setFontMapping(const QString& key, const QString& value) {
    qDebug() << "set font" << key << "->" << value;
    m_fontCache->insert(key, value);
    emit refresh();
    emit fontsChanged();
}

void FigmaQml::resetFontMappings() {
    m_fontCache->clear();
    emit refresh();
    emit fontsChanged();
}


void FigmaQml::createDocumentSources(const QByteArray &data) {
    const auto json = object(data);
    if(!json)
        return;
    m_sourceDoc.reset();
    m_targetDir = m_qmlDir + sourceViewPath;
    m_embedImages = m_flags & EmbedImages;



    createDocument<FigmaDataDocument>(*json);

}

void FigmaQml::restore(int flags, const QVariantMap& imports) {
    m_flags = flags;
    m_imports = imports;
}

void FigmaQml::cleanDir(const QString& dirName) {
    QDir dir(dirName);
    const auto entries = dir.entryInfoList();
    for(const auto& e : entries) {
        if(e.isFile() && !dir.remove(e.fileName()))
            emit error(toStr("Cannot remove", e.fileName()));
    }
}

std::optional<QJsonObject> FigmaQml::object(const QByteArray &data) {
    if(data.isEmpty())
        return std::nullopt;

    QJsonParseError parseError;
    const auto json = QJsonDocument::fromJson(data, &parseError);
    if(parseError.error != QJsonParseError::NoError) {
       emit this->error(QString("When reading JSON: %1 at %2")
                .arg(parseError.errorString())
                .arg(parseError.offset));
        return std::nullopt;
    }

    if(!json.isObject()) {
        emit error("Object expected");
        return std::nullopt;
    }
    return json.object();
}

bool FigmaQml::busy() const {
    return m_busy;
}

QString FigmaQml::nearestFontFamily(const QString& requestedFont, bool useAlt) {
    if(!useAlt) {
        const QFont font(requestedFont);
        const QFontInfo fontInfo(font);  //this return mapped family
        const auto value = fontInfo.family();
        return value;
    } else {
#ifdef QT5
        QFontDatabase fdb;
        const QStringList fontFamilies = fdb.families();
#else
        const QStringList fontFamilies = QFontDatabase::families();
#endif
        int min = std::numeric_limits<int>::max();
        int index = -1;
        for(auto ff = 0; ff < fontFamilies.size() ; ff++) {
            const auto distance = levenshteinDistance(fontFamilies[ff], requestedFont);
            if(distance < min) {
                index = ff;
                min = distance;
            }
        }
        if(index < 0) {
            return requestedFont;
        }
        const auto value = fontFamilies[index];
        return value;
    }
}

void FigmaQml::setSignals(bool allow) {
    blockSignals(!allow);
}

void FigmaQml::parseError(const QString& str, bool isFatal) {
    if(m_state != State::Suspend) {
        if(!m_doCancel) {
            if(isFatal) {
                m_ok = false;
                emit error(str);
            } else
                emit warning(str);
        }
    }
}

std::optional<std::tuple<QByteArray, int>> FigmaQml::getImage(const QString& imageRef, bool isRendering) {
    if(isRendering) {
        const auto imageData = mProvider.cachedRendering(imageRef);
        if(imageData)
            return imageData;
        mProvider.getRendering(imageRef);
    } else {
        const auto imageData = mProvider.cachedImage(imageRef);
        if(imageData)
            return imageData;
        mProvider.getImage(imageRef, QSize(m_imageDimensionMax, m_imageDimensionMax));
    }
    return std::nullopt;
}

void FigmaQml::suspend() {
    m_state = State::Suspend;
}

QByteArray FigmaQml::imageData(const QString& imageRef, bool isRendering) {
    if(!m_ok || m_doCancel)
        return QByteArray();
    if(imageRef == FigmaParser::PlaceHolder)
        return m_brokenPlaceholder;
    else {
        if(m_embedImages) {
            const auto imageData = getImage(imageRef, isRendering);
            if(!imageData) {
                suspend();
                return{};
            }
            const auto& [bytes, mime] = imageData.value();
            if(bytes.isEmpty())
                return QByteArray();
            Q_ASSERT(mime == JPEG || mime == PNG);
            const QByteArray mimeString = mime == JPEG ? "jpeg" : "png";
            return "data:image/" + mimeString + ";base64," + bytes.toBase64();
        } else {
            if(!m_imageFiles.contains(imageRef)) {
                const auto imageData = getImage(imageRef, isRendering);
                if(!imageData) {
                    suspend();
                    return{};
                }
                const auto& [bytes, mime] = imageData.value();
                if(!addImageFileData(imageRef, bytes, mime, isRendering))
                    return {};
            }
            return (Images.mid(1) +  m_imageFiles[imageRef].second).toLatin1();
        }
    }
}

QByteArray FigmaQml::nodeData(const QString& id) {
    if(!m_ok || m_doCancel)
        return QByteArray();
    const auto node = mProvider.cachedNode(id);
    if(!node) {
        mProvider.getNode(id);
        suspend();
        return {};
    }
    return *node;
}

QString FigmaQml::fontInfo(const QString& requestedFont) {
    if(m_flags & KeepFigmaFontName)
        return requestedFont;
    if(m_fontCache->contains(requestedFont))
        return (*m_fontCache)[requestedFont];
    const auto value = nearestFontFamily(requestedFont, m_flags & AltFontMatch);
    m_fontCache->insert(requestedFont, value);
    return value;
}

template<class T>
std::unique_ptr<T> FigmaQml::doCreateDocument(const QJsonObject& obj) {
    m_ok = true;
    m_doCancel = false; // uff UniqueConnection requires a member func
    const auto d = QObject::connect(this, &FigmaQml::cancelled, this, &FigmaQml::doCancel, Qt::UniqueConnection);

    RAII(([d](){QObject::disconnect(d);}));

    m_busy = true;
    emit busyChanged();
    RAII([this]() {m_busy = false; emit busyChanged();});

    auto doc = std::make_unique<T>(m_targetDir, FigmaParser::name(obj));

    Q_ASSERT(m_imageDimensionMax > 0);

    // erase 1st
    QDir dir(m_targetDir);
    dir.removeRecursively();
    if(!ensureDirExists(m_targetDir))
       return nullptr;

    QByteArray header = QString(FileHeader).toLatin1();
    const auto keys =  m_imports.keys();
    for(const auto& k : keys) {
#ifdef QT5
        const auto ver = QVersionNumber::fromString(m_imports[k].toString());
        if(ver.isNull()) {
            emit error(toStr("Invalid imports version", m_imports[k].toString(), "for", k));
            return nullptr;
        }
        header += QString("import %1 %2\n").arg(k).arg(m_imports[k].toString());
#else
        header += QString("import %1\n").arg(k);
#endif
    }

    auto components_opt = FigmaParser::components(obj, *this);

    TIMED_START(t3)

#ifdef NO_CONCURRENT
    if(!components_opt) {
        return nullptr;
    }
    const auto& components = components_opt.value();
    for(const auto& c : components) {
      const auto component_opt = FigmaParser::component(c->object(), m_flags, *this, components);
      if(!m_ok || m_doCancel || !component_opt)
          return nullptr;
      const auto& component = component_opt.value();
      if(component.data().isEmpty()) {
          emit error(toStr("Invalid component", component.name()));
          return nullptr;
      }

      doc->addComponent(components[component.id()]->name(), components[component.id()]->object(), header + component.data());

      QStringList componentNames;
      for(const auto& id : component.components()) {
          Q_ASSERT(components.contains(id)); //just check here
          const auto compname = components[id]->name();
          componentNames.append(compname);
      }

      QFile componentFile(m_targetDir + "/" + validFileName(c->name()) + ".qml");
      if(componentFile.exists()) {
          emit error(toStr("File already exists", componentFile.fileName(), QString("\"%1\" \"%2\"").arg(c->name()).arg(c->description())));
          return nullptr;
      }
      if(!componentFile.open(QIODevice::WriteOnly)) {
          emit error(toStr("Cannot write", componentFile.fileName(), componentFile.errorString()));
          return nullptr;
      }
      componentFile.write(header + component.data());
    }
#else

    const auto componentData =
            Concurrent::mapped<FigmaParser::Components::iterator, std::function<FigmaParser::Element (const FigmaParser::Components::const_iterator::value_type &) >>
                          (components.begin(), components.end(), [&, this](const auto& c)->FigmaParser::Element {

            if(!ok || doCancel)
                return FigmaParser::Element();

             const auto component = FigmaParser::component(c->object(), m_flags, errorFunction, imageFunction, fontFunction, components);

            if(component.data().isEmpty()) {
                ok = false;
                emit error(toStr("Invalid component", component.name()));
                return FigmaParser::Element();
            }

            QFile componentFile(targetDir + c->name() + ".qml");
#ifdef _DEBUG
            if(componentFile.exists()) {
                emit info(toStr("File updated", componentFile.fileName(), QString("\"%1\" \"%2\"").arg(c->name()).arg(c->description())));
            }
#endif
            if(!componentFile.open(QIODevice::WriteOnly)) {
                ok = false;
                emit error(toStr("Cannot write", componentFile.fileName(), componentFile.errorString()));
                return FigmaParser::Element();
            }
            componentFile.write(header + component.data());

            return component;
        });

    FutureWatcher<FigmaParser::Element> watch;
    QEventLoop loop;
    QObject::connect(&watch, &FutureWatcher<FigmaParser::Element>::finished, &loop, &QEventLoop::quit);
    QObject::connect(this, &FigmaQml::error, [&doCancel](){
        doCancel = true;
    });
    watch.setFuture(componentData);
    loop.exec();

    if(!watch.isFinished()) {
        watch.waitForFinished();
        return nullptr;
    }

    if(!ok || doCancel)
        return nullptr;

    const std::function<void (const FigmaParser::Element& c)> addComponent = [&](const FigmaParser::Element& c) { //recursive lambdas cannot be declared auto
        if(!ok || doCancel)
            return;
        const auto name = components[c.id()]->name();
        if(doc->containsComponent(name))
            return;
        QStringList componentNames;
        doc->addComponent(name, components[c.id()]->object(), header + c.data());
        for(const auto& id : c.components()) {
            if(!ok || doCancel)
                return;
            Q_ASSERT(components.contains(id)); //just check here
            const auto compname = components[id]->name();
            componentNames.append(compname);
            const auto cit = std::find_if(componentData.begin(), componentData.end(), [&id](const auto& c){return c.id() == id;});
            addComponent(*cit);
        }
        doc->setComponents(name, componentNames);
    };

    for(const auto& c : componentData) {
        addComponent(c);
    }

#endif

    TIMED_END(t3, "Component")
    TIMED_START(t4)

    int currentCanvas = 0;
#ifdef NO_CONCURRENT
    int currentElement = 0;
#else
    std::atomic_int currentElement = 0;
#endif
    const auto canvases_opt = FigmaParser::canvases(obj, *this);
    if(!canvases_opt)
        return nullptr;
    const auto& canvases = canvases_opt.value();
    for(const auto& c : canvases) {
        ++currentCanvas;
        currentElement = 0;
        auto canvas = doc->addCanvas(c.name());
#ifdef NO_CONCURRENT
        const auto elements = c.elements();
        for(const auto& f : elements) {
            if(m_state == State::Suspend)
                return nullptr;
            if(m_doCancel)
                return nullptr;
            bool hasElement = true;
            if(!m_filter.isEmpty()) {
                ++currentElement;
                if(!m_filter.keys().contains(currentCanvas) || !m_filter[currentCanvas].contains(currentElement))
                    hasElement = false;
            }

            const auto element_opt = hasElement ? FigmaParser::element(f, m_flags, *this, components) : FigmaParser::Element();
            if(!element_opt)
                return nullptr;
            const auto& element = element_opt.value();
#else
        auto elements = c.elements();
        Future<FigmaParser::Element> elementData =
        Concurrent::mapped<FigmaParser::Canvas::ElementVector::iterator, std::function<FigmaParser::Element (const FigmaParser::Canvas::ElementVector::value_type&)> > (
        elements.begin(), elements.end(), [&, this](const auto& f) {
            if(!ok || doCancel)
                return FigmaParser::Element();
            if(!m_filter.isEmpty()) {
                const int ce = currentElement.fetch_add(1);
                if(!m_filter.contains(currentCanvas) || !m_filter[currentCanvas].contains(ce))
                    return FigmaParser::Element();
            }
            return FigmaParser::element(f, m_flags, errorFunction, imageFunction, fontFunction, components);

        });

        FutureWatcher<FigmaParser::Element> watch;
        QEventLoop loop;
        QObject::connect(&watch, &FutureWatcher<FigmaParser::Element>::finished, &loop, &QEventLoop::quit);
        QObject::connect(this, &FigmaQml::error, [&doCancel](){
            doCancel = true;
        });
        watch.setFuture(elementData);
        loop.exec();

        if(!watch.isFinished()) {
            watch.waitForFinished();
            return nullptr;
        }

        if(!ok || doCancel)
            return nullptr;

        for(const auto& element : elementData) {
#endif
            if(m_state == State::Suspend)
                return nullptr;

            if(m_doCancel)
                return nullptr;
            if(!m_ok) {
                return nullptr;
            }
            if(!element.data().isEmpty())
                canvas->addElement(element.name(), header + element.data());
            else
                canvas->addElement(element.name(), header + "Text{text: \"filtered out\"}");
            QStringList componentNames;
            for(const auto& id : element.components()) {
                componentNames.append(components[id]->name());
            }
            doc->setComponents(element.name(), std::move(componentNames));
        }
    }

    TIMED_END(t4, "elements")
    return doc;
}

